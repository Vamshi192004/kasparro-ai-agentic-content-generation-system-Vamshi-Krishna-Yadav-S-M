# Agentic Content Generation System

## Overview
An **LLM-driven agentic system** that transforms raw product data into marketing content using **LangGraph** and **Google Gemini**. The system features a multi-agent architecture with retry mechanisms, content quality validation, and a self-correction loop.

## Key Features
- ✅ **LLM-Generated Content Only**: All content generated by Google Gemini - no mocks or external search
- ✅ **Self-Correction Loop**: Reviewer agent validates and triggers regeneration if quality is insufficient
- ✅ **Strict Validation**: Pydantic schemas with business requirement validators
- ✅ **Retry Mechanisms**: Exponential backoff for robust error handling
- ✅ **Quality Assurance**: Minimum 15 FAQs with category diversity and content quality checks
- ✅ **Real Testing**: Integration tests with actual API calls (no mocks)

## System Capabilities

### What It Does
- Parses raw product JSON into normalized schemas
- Generates 15+ high-quality FAQs across multiple categories
- Creates product landing pages with compelling copy
- Generates competitive comparison pages
- Validates all outputs against quality criteria
- Retries failed operations with exponential backoff

### Current Limitations
- **No Tool Usage**: Agents are primarily prompt-based without external tool integration
- **Limited Agentic Reasoning**: State management is functional but not deeply agentic
- **Basic Error Recovery**: Retry mechanisms are implemented but graceful degradation is limited
- **No Advanced Features**: No web search, no database integration, no multi-modal capabilities
- **API Costs**: Real LLM calls consume API credits - use responsibly

## Repository Structure
```text
/src
  /agents       # LLM-powered Worker Agents (parser, qgen, page agents, reviewer)
  /core         # Graph definition, State, Schemas, Validators, Retry Utils
  main_graph.py # Entry point
/tests          # Integration and unit tests with real LLM calls
/docs           # Detailed system design documentation
dataset.json    # Sample input data
```

## Quick Start

### 1. Prerequisites
- Python 3.9+
- Google Cloud API Key (Gemini API access)

### 2. Installation
```bash
pip install -r requirements.txt
```

### 3. Configuration
Create a `.env` file in the root directory:
```env
GOOGLE_API_KEY=your_actual_api_key_here
```

### 4. Run the Pipeline
```bash
python src/main_graph.py
```

### 5. CLI Usage (Custom Tone)
Customize the tone of voice:
```bash
python src/main_graph.py --tone "Luxury" --input "dataset.json"
```

## Testing

### Run Unit Tests (Fast)
```bash
pytest tests/test_schemas.py -v
```

### Run Integration Tests (Slow - Uses Real API)
```bash
pytest tests/test_integration.py -v -m slow
```

**Warning**: Integration tests make real API calls and will consume credits.

## Documentation
See [docs/projectdocumentation.md](docs/projectdocumentation.md) for detailed architecture and design decisions.

## Architecture Highlights

### Why LangGraph?
LangGraph enables **cyclic graph capabilities** for self-correction loops. Traditional DAGs cannot easily handle "retry until good" logic without complex external controllers.

### Why Google Gemini?
**Gemini 1.5 Flash** provides high speed and large context windows, allowing us to pass entire product schemas between agents without token limits or high latency.

### Why Pydantic?
Pydantic enforces strict schemas with custom validators, acting as "guardrails" to ensure 100% machine-readable output. This prevents malformed JSON from reaching downstream systems.

## Troubleshooting

### API Key Issues
```bash
# Verify API key is set
echo $GOOGLE_API_KEY  # Linux/Mac
echo %GOOGLE_API_KEY%  # Windows
```

### FAQ Count Issues
If FAQ generation fails with "insufficient questions":
- Check that question generator is producing 15+ questions
- Review logs for retry attempts
- Verify API quota is not exceeded

### Quality Validation Failures
If content is rejected by reviewer:
- Check logs for specific feedback
- Ensure product data has sufficient detail
- Verify no external search indicators in prompts

## Contributing
This is a demonstration system. For production use, consider:
- Adding tool usage capabilities to agents
- Implementing more sophisticated state management
- Adding database persistence
- Implementing caching to reduce API costs
- Adding monitoring and observability

